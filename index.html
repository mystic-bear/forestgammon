<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#2E7D32">
    <title>Ïà≤ÏÜçÏùò Î∞±Í∞úÎ®º (Ver 18.0 - Final Risk Sync)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        :root {
            --bg-color: #2E7D32;
            --panel-bg: rgba(0,0,0,0.75);
            --accent-color: #FFD700;
            --p1-color: #F5F5F5;
            --p2-color: #3E2723;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Jua', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

        body {
            background-color: var(--bg-color);
            color: white;
            height: 100vh; width: 100vw;
            overflow: hidden;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }

        #portrait-warning {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1b5e20; z-index: 9999;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; color: white;
        }
        @media (orientation: portrait) { 
            body.mobile-layout #portrait-warning { display: flex; } 
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            z-index: 2000; transition: opacity 0.3s;
        }
        .screen.hidden { opacity: 0; pointer-events: none; visibility: hidden; }

        /* --- MODE SELECT --- */
        .mode-select-box { display: flex; gap: 20px; margin-bottom: 30px; }
        .btn-start-mode {
            padding: 20px 30px; border-radius: 20px; border: none;
            font-size: 1.5rem; font-weight: bold; cursor: pointer;
            transition: 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .btn-start-mode:active { transform: scale(0.95); }
        .btn-mobile { background: #4CAF50; color: white; }
        .btn-pc { background: #2196F3; color: white; }

        /* --- LAYOUT --- */
        .game-container { display: grid; width: 100%; height: 100%; gap: 0; padding: 0; z-index: 1; }
        
        body.pc-layout .game-container { grid-template-columns: 280px 1fr 280px; width: 98%; height: 95vh; gap: 15px; }
        body.mobile-layout .game-container { grid-template-columns: 95px 1fr 95px; width: 100%; height: 100%; }

        .panel { background: var(--panel-bg); display: flex; flex-direction: column; z-index: 10; }
        
        body.pc-layout .panel { border-radius: 20px; padding: 20px; border: 2px solid rgba(255,255,255,0.1); }
        body.pc-layout .panel-left { justify-content: flex-start; gap: 15px; }
        body.pc-layout .panel-right { justify-content: space-between; }
        
        body.mobile-layout .panel { padding: 5px; background: rgba(0,0,0,0.7); }
        body.mobile-layout .panel-left { border-right: 1px solid rgba(255,255,255,0.1); justify-content: flex-start; gap: 5px; }
        body.mobile-layout .panel-right { border-left: 1px solid rgba(255,255,255,0.1); justify-content: space-between; align-items: center; }

        .info-header { text-align: center; color: var(--accent-color); margin-bottom: 5px; }
        body.pc-layout .info-header { font-size: 1.5rem; }
        body.mobile-layout .info-header { font-size: 0.8rem; margin-bottom: 2px; opacity: 0.9; }

        .player-box {
            background: rgba(255,255,255,0.1); border-radius: 12px;
            display: flex; flex-direction: column; 
            border-left: 5px solid transparent; transition: 0.3s;
        }
        body.pc-layout .player-box { padding: 15px; gap: 5px; }
        body.mobile-layout .player-box { padding: 6px; gap: 2px; border-radius: 6px; border-left-width: 3px; width: 100%; }
        .player-box.active { background: rgba(255,255,255,0.25); border-left-color: #FFD700; }
        
        .p-name { font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        body.pc-layout .p-name { font-size: 1.3rem; }
        body.mobile-layout .p-name { font-size: 0.85rem; }

        .p-stat { color: #ddd; display: flex; justify-content: space-between; }
        body.pc-layout .p-stat { font-size: 1rem; }
        body.mobile-layout .p-stat { font-size: 0.7rem; align-items: center; }

        .p-score { color: #FFD700; font-weight: bold; }
        body.pc-layout .p-score { font-size: 1.2rem; }
        body.mobile-layout .p-score { font-size: 0.9rem; }

        .p-log { font-size: 0.8rem; color: #aaa; margin-top: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        body.mobile-layout .p-log { display: none; }

        .board-area {
            position: relative; background: #5D4037; 
            display: flex; justify-content: center; align-items: center; overflow: hidden;
        }
        body.pc-layout .board-area { border-radius: 15px; border: 8px solid #3E2723; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        body.mobile-layout .board-area { border: none; }
        
        canvas { width: 100%; height: 100%; cursor: pointer; display: block; }

        .msg-box { 
            text-align: center; color: white; display: flex; align-items: center; justify-content: center; 
            background: rgba(0,0,0,0.3); border-radius: 10px; width: 100%;
        }
        body.pc-layout .msg-box { font-size: 1.2rem; height: 2em; margin-bottom: 15px; }
        body.mobile-layout .msg-box { font-size: 0.8rem; height: 2em; margin-bottom: 4px; border-radius: 4px; line-height: 1.1; word-break: keep-all; }

        .dice-area { display: flex; flex-direction: column; align-items: center; width: 100%; }
        body.pc-layout .dice-area { margin-bottom: 20px; }
        body.mobile-layout .dice-area { margin-bottom: 5px; }

        .dice-box { display: flex; justify-content: center; }
        body.pc-layout .dice-box { gap: 15px; height: 60px; }
        body.mobile-layout .dice-box { gap: 4px; height: 32px; margin-bottom: 2px; }

        .die { background: white; color: #333; display: flex; align-items: center; justify-content: center; font-weight: bold; transition: 0.2s; }
        body.pc-layout .die { width: 60px; height: 60px; border-radius: 12px; font-size: 2rem; box-shadow: 0 5px 0 #999; }
        body.mobile-layout .die { width: 32px; height: 32px; border-radius: 6px; font-size: 1.1rem; box-shadow: 0 2px 0 #999; }
        .die.used { opacity: 0.3; transform: scale(0.85); box-shadow: none; filter: grayscale(100%); }
        
        .moves-left { color: #FFD700; background: rgba(0,0,0,0.5); visibility: hidden; }
        body.pc-layout .moves-left { margin-top: 8px; font-size: 0.9rem; padding: 2px 10px; border-radius: 10px; }
        body.mobile-layout .moves-left { font-size: 0.65rem; padding: 1px 4px; border-radius: 4px; white-space: nowrap; }
        .moves-left.show { visibility: visible; }

        .btn { 
            border: none; cursor: pointer; color: white; font-weight: bold; width: 100%; transition: transform 0.1s; 
            display: flex; justify-content: center; align-items: center;
        }
        .btn:active { transform: translateY(2px); box-shadow: none; }
        .btn:disabled { background: #78909C; opacity: 0.5; cursor: not-allowed; }
        
        body.pc-layout .btn { padding: 15px; font-size: 1.1rem; border-radius: 12px; box-shadow: 0 4px 0 rgba(0,0,0,0.3); margin-bottom: 10px; }
        body.pc-layout .sub-btn-wrapper { display: flex; gap: 10px; width: 100%; }
        
        body.mobile-layout .btn { padding: 0; height: 38px; font-size: 0.85rem; border-radius: 6px; box-shadow: 0 2px 0 rgba(0,0,0,0.3); margin-bottom: 4px; }
        body.mobile-layout .btn-roll { font-size: 0.95rem; }
        body.mobile-layout .btn-double { height: 30px; font-size: 0.8rem; }
        body.mobile-layout .sub-btn-wrapper { display: flex; gap: 3px; margin-top: 2px; width: 100%; }
        body.mobile-layout .btn-sub { font-size: 1rem; height: 34px; flex: 1; }

        .btn-roll { background: #FF6F00; }
        .btn-double { background: #5E35B1; }
        .btn-sub { background: #546E7A; }
        .btn-hint { background: #039BE5; }

        /* Menu */
        .menu-box {
            background: white; color: #333; border-radius: 25px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            overflow-y: auto; max-height: 90vh;
        }
        body.pc-layout .menu-box { padding: 30px; width: 450px; }
        body.mobile-layout .menu-box { padding: 20px; width: 85%; max-width: 400px; border-radius: 15px; }

        .menu-title { color: var(--bg-color); font-weight: bold; margin-bottom: 20px; }
        body.pc-layout .menu-title { font-size: 2.5rem; }
        body.mobile-layout .menu-title { font-size: 1.8rem; margin-bottom: 10px; }

        .menu-label { text-align: left; font-weight: bold; color: #555; margin: 15px 0 5px; cursor: pointer; user-select: none; }
        
        .toggle-group { display: flex; background: #eee; border-radius: 15px; padding: 4px; margin-bottom: 15px; }
        .toggle-opt { flex: 1; padding: 10px; border-radius: 12px; cursor: pointer; color: #777; transition: 0.2s; font-weight: bold; }
        .toggle-opt.selected { background: #FF6F00; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

        .btn-mode {
            display: flex; align-items: center; border-radius: 12px; 
            border: 2px solid #eee; background: white; cursor: pointer; transition: 0.2s;
            margin-bottom: 8px; width: 100%; text-align: left;
            justify-content: flex-start;
        }
        body.pc-layout .btn-mode { padding: 12px 15px; }
        body.mobile-layout .btn-mode { padding: 8px; margin-bottom: 5px; }

        .btn-mode:hover { border-color: #FF6F00; transform: translateX(5px); }
        .btn-mode .badge { 
            background: #555; color: white; padding: 2px 8px; border-radius: 4px; 
            font-size: 0.8rem; margin-right: 10px; min-width: 45px; text-align:center; 
            flex-shrink: 0;
        }
        .btn-mode .desc { margin-left: auto; font-size: 0.8rem; color: #999; white-space: nowrap; }

        .btn-mode.pvp { background: #E3F2FD; border-color: #90CAF9; }
        .pvp-title.reception { color: #00E676 !important; text-shadow: 0 0 5px rgba(0,230,118,0.3); }

        .toast {
            position: fixed; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.95); color: #FFD700; padding: 15px 25px;
            border-radius: 30px; font-size: 1.1rem; pointer-events: none;
            opacity: 0; transition: opacity 0.3s; z-index: 3000; border: 2px solid white; 
            white-space: pre-line; text-align: center; line-height: 1.5;
        }
        .toast.show { opacity: 1; transform: translate(-50%, -10px); }

        .modal-box { background: white; color: #333; padding: 30px; border-radius: 20px; text-align: center; width: 380px; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        
        #confetti-canvas { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1500; }
        #mode-select-screen { z-index: 3000; background: #1b5e20; }
    </style>
</head>
<body>

    <div id="portrait-warning">
        <div style="font-size:3rem;">üì±üîÑ</div>
        <h2>Í∞ÄÎ°úÎ°ú ÌöåÏ†ÑÌï¥Ï£ºÏÑ∏Ïöî</h2>
    </div>

    <div id="mode-select-screen" class="screen">
        <div style="text-align:center;">
            <h1 style="font-size:3rem; margin-bottom:40px; color:#FFD700;">üé≤ Ïà≤ÏÜçÏùò Î∞±Í∞úÎ®º</h1>
            <div class="mode-select-box">
                <button class="btn-start-mode btn-mobile" onclick="ui.setMode('mobile')">üì± Î™®Î∞îÏùº Î™®Îìú</button>
                <button class="btn-start-mode btn-pc" onclick="ui.setMode('pc')">üíª PC Î™®Îìú</button>
            </div>
            <div style="color:#aaa; font-size:0.9rem;">Ver 18.0 Final</div>
        </div>
    </div>

    <div id="start-screen" class="screen hidden">
        <div class="menu-box">
            <div class="menu-title">üé≤ Ïà≤ÏÜçÏùò Î∞±Í∞úÎ®º</div>
            
            <div class="menu-label">üèÜ Î™©Ìëú Ï†êÏàò</div>
            <div class="toggle-group">
                <div class="toggle-opt" onclick="menu.selectScore(3, this)">3Ï†ê</div>
                <div class="toggle-opt selected" onclick="menu.selectScore(5, this)">5Ï†ê</div>
                <div class="toggle-opt" onclick="menu.selectScore(7, this)">7Ï†ê</div>
            </div>

            <div class="menu-label" onclick="menu.triggerSecret()">üéÆ ÎåÄÏ†Ñ Î™®Îìú</div>
            
            <button class="btn-mode pvp" onclick="game.startPvP()">
                <span class="icon-span" style="font-size:1.5rem; margin-right:10px;">üë•</span>
                <div style="flex:1;">
                    <div id="pvp-text" class="pvp-title" style="font-weight:bold; font-size:1.1rem; color:#1565C0;">2Ïù∏ ÎåÄÏ†Ñ (PvP)</div>
                    <div style="font-size:0.8rem; color:#555;">ÏπúÍµ¨ÏôÄ Ìï®Íªò ÌîåÎ†àÏù¥</div>
                </div>
            </button>

            <div style="height:1px; background:#ddd; margin:15px 0;"></div>
            
            <div id="pve-list">
                <button class="btn-mode" onclick="game.startPvE(1)">
                    <span class="badge" style="background:#FF9800">Lv.1</span> 
                    <span>üêøÔ∏è Í∏∏Ïπò Îã§ÎûåÏ•ê</span> 
                    <span class="desc">Ï¥àÎ≥¥</span>
                </button>
                <button class="btn-mode" onclick="game.startPvE(2)">
                    <span class="badge" style="background:#795548">Lv.2</span> 
                    <span>ü¶ù Ïã¨Ïà† ÎÑàÍµ¨Î¶¨</span> 
                    <span class="desc">Í≥µÍ≤©Ìòï</span>
                </button>
                <button class="btn-mode" onclick="game.startPvE(3)">
                    <span class="badge" style="background:#E65100">Lv.3</span> 
                    <span>ü¶ä ÏñåÏ≤¥ Ïó¨Ïö∞</span> 
                    <span class="desc">Î∞©Ïñ¥Ìòï</span>
                </button>
                <button class="btn-mode" onclick="game.startPvE(4)">
                    <span class="badge" style="background:#455A64">Lv.4</span> 
                    <span>ü¶â ÎòëÎòë Î∂ÄÏóâÏù¥</span> 
                    <span class="desc">ÏàôÎ†®Ïûê</span>
                </button>
                <button class="btn-mode" onclick="game.startPvE(5)">
                    <span class="badge" style="background:#2E7D32">Lv.5</span> 
                    <span>üå≥ Ïà≤Ïùò Ï£ºÏù∏</span> 
                    <span class="desc">Ï¥àÍ≥†Ïàò</span>
                </button>
            </div>
        </div>
    </div>

    <div id="game-screen" class="screen hidden" style="background:none; pointer-events:auto;">
        <div class="game-container">
            <div class="panel panel-left">
                <div class="info-header">SCORE</div>
                <div id="p1-box" class="player-box">
                    <div class="p-name">üê∞ P1 (ÎÇò)</div>
                    <div class="p-stat">
                        <span class="p-score" id="score-p1">0</span>
                        <span class="p-pip">PIP: <span id="pip-p1">167</span></span>
                    </div>
                    <div class="p-log" id="log-p1">Í∏∞Î°ù ÏóÜÏùå</div>
                </div>
                <div id="p2-box" class="player-box">
                    <div class="p-name" id="p2-name">üêª P2</div>
                    <div class="p-stat">
                        <span class="p-score" id="score-p2">0</span>
                        <span class="p-pip">PIP: <span id="pip-p2">167</span></span>
                    </div>
                    <div class="p-log" id="log-p2">Í∏∞Î°ù ÏóÜÏùå</div>
                </div>
                <div style="margin-top:auto; text-align:center;">
                    <div style="font-size:0.8rem; color:#aaa;">CUBE</div>
                    <div style="font-size:2.5rem; font-weight:bold; color:#FFD700;" id="cube-val">1</div>
                    <div style="font-size:0.9rem; color:#ccc;" id="cube-owner">Ï§ëÏïô</div>
                </div>
            </div>

            <div class="board-area" id="board-container">
                <canvas id="board"></canvas>
            </div>

            <div class="panel panel-right">
                <div style="width:100%">
                    <div class="msg-box" id="msg-box">Ï§ÄÎπÑ ÏôÑÎ£å</div>
                    <div class="dice-area">
                        <div class="dice-box">
                            <div class="die" id="die1">?</div>
                            <div class="die" id="die2">?</div>
                        </div>
                        <div id="moves-left" class="moves-left">ÎÇ®ÏùÄ: 0</div>
                    </div>
                    <button id="btn-roll" class="btn btn-roll" onclick="game.rollDice()">üé≤ Ï£ºÏÇ¨ÏúÑ</button>
                </div>
                <div style="width:100%">
                    <button id="btn-double" class="btn btn-double" onclick="game.humanOfferDouble()">üíé 2Î∞∞</button>
                    <div class="sub-btn-wrapper">
                        <button id="btn-undo" class="btn btn-sub" onclick="game.undo()"><span class="btn-text">Î¨¥Î•¥Í∏∞</span></button>
                        <button id="btn-hint" class="btn btn-hint" onclick="game.getHint()"><span class="btn-text">ÌûåÌä∏</span></button>
                        <button class="btn btn-sub" onclick="game.toMenu()"><span class="btn-text">Î©îÎâ¥</span></button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="modal-double" class="screen hidden">
        <div class="modal-box">
            <h2 style="color:#5E35B1; margin-bottom:15px;">üíé ÎçîÎ∏î Ï†úÏïà!</h2>
            <p id="double-msg" style="color:#555; margin-bottom:20px; font-size:1.1rem;">ÌåêÎèàÏùÑ 2Î∞∞Î°ú Ïò¨Î¶¨ÏãúÍ≤†ÏäµÎãàÍπå?</p>
            <div style="display:flex; gap:10px;">
                <button class="btn" style="background:#4CAF50;" onclick="game.resolveDouble(true)">ÏàòÎùΩ</button>
                <button class="btn" style="background:#F44336;" onclick="game.resolveDouble(false)">Ìè¨Í∏∞</button>
            </div>
        </div>
    </div>

    <div id="modal-win" class="screen hidden">
        <div class="modal-box">
            <h1 id="win-title" style="font-size:3rem; margin-bottom:10px; color:#FF6F00;">ÏäπÎ¶¨!</h1>
            <p id="win-desc" style="color:#666; margin-bottom:20px;">...</p>
            <button id="btn-win-action" class="btn btn-roll" onclick="game.nextRound()">Îã§Ïùå ÎùºÏö¥Îìú</button>
        </div>
    </div>

    <div id="toast" class="toast">Î©îÏãúÏßÄ</div>
    <canvas id="confetti-canvas"></canvas>

<script>
const P1 = 1; 
const P2 = 2; 
const OFF = 26; 

const menu = {
    targetScore: 5,
    selectScore: (s, el) => {
        menu.targetScore = s;
        document.querySelectorAll('.toggle-opt').forEach(e => e.classList.remove('selected'));
        el.classList.add('selected');
    },
    secretClicks: 0,
    secretTimer: null,
    triggerSecret: () => {
        menu.secretClicks++;
        if (menu.secretTimer) clearTimeout(menu.secretTimer);
        menu.secretTimer = setTimeout(() => { menu.secretClicks = 0; }, 3000);
        if (menu.secretClicks === 4) {
            game.receptionMode = !game.receptionMode;
            menu.secretClicks = 0;
            const txt = document.getElementById('pvp-text');
            if(game.receptionMode) txt.classList.add('reception'); 
            else txt.classList.remove('reception'); 
        }
    }
};

const AI_DATA = {
    1: { name: "Í∏∏Ïπò Îã§ÎûåÏ•ê", icon: "üêøÔ∏è" },
    2: { name: "Ïã¨Ïà† ÎÑàÍµ¨Î¶¨", icon: "ü¶ù" },
    3: { name: "ÏñåÏ≤¥ Ïó¨Ïö∞", icon: "ü¶ä" },
    4: { name: "ÎòëÎòë Î∂ÄÏóâÏù¥", icon: "ü¶â" },
    5: { name: "Ïà≤Ïùò Ï£ºÏù∏", icon: "üå≥" }
};

class Backgammon {
    constructor() {
        this.board = [];
        this.bar = { [P1]: 0, [P2]: 0 };
        this.off = { [P1]: 0, [P2]: 0 };
        this.matchScore = { [P1]: 0, [P2]: 0 };
        this.cube = 1; this.cubeOwner = 0;
        this.turn = P1;
        this.dice = [];
        this.moves = []; 
        this.history = [];
        this.isPvP = false;
        this.aiLevel = 0;
        this.receptionMode = false;
        
        this.selectedPoint = -1;
        this.validDestinations = [];
        this.hintMove = null;
    }

    startPvP() {
        this.isPvP = true;
        this.p2Name = "üêª P2 (ÏπúÍµ¨)";
        this.startMatch();
    }

    startPvE(level) {
        this.isPvP = false;
        this.aiLevel = level;
        let info = AI_DATA[level];
        this.p2Name = `${info.icon} ${info.name}`;
        this.startMatch();
    }

    startMatch() {
        ui.hide('start-screen');
        ui.show('game-screen');
        setTimeout(() => renderer.resize(), 100);

        this.matchScore = { [P1]: 0, [P2]: 0 };
        document.getElementById('p2-name').innerText = this.p2Name;
        this.initRound();
        ui.updateScore();
    }

    initRound() {
        this.board = Array(25).fill(null).map(() => []);
        this.bar = { [P1]: 0, [P2]: 0 };
        this.off = { [P1]: 0, [P2]: 0 };
        this.history = [];
        this.cube = 1; this.cubeOwner = 0;
        this.hintMove = null;

        this.add(P1, 1, 2); this.add(P1, 12, 5); this.add(P1, 17, 3); this.add(P1, 19, 5);
        this.add(P2, 24, 2); this.add(P2, 13, 5); this.add(P2, 8, 3); this.add(P2, 6, 5);

        this.turn = P1;
        this.dice = [];
        this.moves = [];
        
        ui.updateBoard();
        ui.updateInfo();
        ui.updateScore(); 
        ui.setPhase('ROLL');
        ui.updateDice('?', '?');
    }

    add(p, i, c) { for(let k=0; k<c; k++) this.board[i].push(p); }

    rollDice() {
        ui.playSound('dice');
        let d1 = Math.floor(Math.random() * 6) + 1;
        let d2 = Math.floor(Math.random() * 6) + 1;

        if (this.receptionMode && this.turn === P1) {
            let magic = this.findWinningRoll(P1);
            if (magic > 0) d1 = magic;
        }

        this.dice = [d1, d2];
        this.moves = (d1===d2) ? [d1, d1, d1, d1] : [d1, d2];
        
        this.saveState();
        this.hintMove = null;

        ui.updateDice(d1, d2); 
        ui.setPhase('MOVE');

        if (!this.hasValidMoves()) {
            ui.setMsg("Ïù¥Îèô Î∂àÍ∞Ä! ÌÑ¥ ÎÑòÏñ¥Í∞ê");
            setTimeout(() => this.endTurn(), 2000);
        } else {
            if (!this.isPvP && this.turn === P2) {
                setTimeout(() => ai.play(), 1000);
            }
        }
    }

    findWinningRoll(player) {
        let opponent = (player === P1) ? P2 : P1;
        let bestRoll = 0;
        let maxDest = -1; 

        let sources = [];
        if (this.bar[player] > 0) sources.push('BAR');
        else for (let i = 1; i <= 24; i++) if (this.board[i].includes(player)) sources.push(i);

        for (let src of sources) {
            let start = (src === 'BAR') ? (player === P1 ? 0 : 25) : src;
            let dir = (player === P1) ? 1 : -1;
            for (let r = 1; r <= 6; r++) {
                let dest = start + (r * dir);
                if (dest >= 1 && dest <= 24) {
                    let stack = this.board[dest];
                    if (stack.length === 1 && stack[0] === opponent) {
                        if (dest > maxDest) {
                            maxDest = dest;
                            bestRoll = r;
                        }
                    }
                }
            }
        }
        return bestRoll;
    }

    getPossibleMoves(from) {
        let res = [];
        let isBar = (from === 'BAR');
        
        if (isBar) {
            if (this.bar[this.turn] === 0) return [];
        } else {
            if (this.bar[this.turn] > 0) return []; 
            if (this.board[from].length === 0 || this.board[from][0] !== this.turn) return [];
        }

        let uniqueDice = [...new Set(this.moves)];
        uniqueDice.forEach(die => {
            let start = isBar ? (this.turn===P1 ? 0 : 25) : from; 
            let dir = (this.turn===P1) ? 1 : -1;
            let dest = start + (die * dir);

            let canOff = this.canBearOff(this.turn);
            if (this.turn===P1 && dest >= 25) {
                if(canOff && (dest===25 || this.noPieceBefore(P1, from))) res.push({dest: 'OFF', die});
            } else if (this.turn===P2 && dest <= 0) {
                if(canOff && (dest===0 || this.noPieceAfter(P2, from))) res.push({dest: 'OFF', die});
            }
            else if (dest >= 1 && dest <= 24) {
                let stack = this.board[dest];
                if(stack.length <= 1 || stack[0] === this.turn) res.push({dest, die});
            }
        });
        return res;
    }

    hasValidMoves() {
        if (this.bar[this.turn] > 0) return this.getPossibleMoves('BAR').length > 0;
        for (let i=1; i<=24; i++) if (this.board[i].length>0 && this.board[i][0]===this.turn) if (this.getPossibleMoves(i).length > 0) return true;
        return false;
    }

    canBearOff(p) {
        if (this.bar[p] > 0) return false;
        let s = (p===P1) ? 1 : 7; let e = (p===P1) ? 18 : 24;
        for(let i=s; i<=e; i++) if(this.board[i].length>0 && this.board[i][0]===p) return false;
        return true;
    }
    noPieceBefore(p, f) { for(let i=19; i<f; i++) if(this.board[i].length>0 && this.board[i][0]===p) return false; return true; }
    noPieceAfter(p, f) { for(let i=f+1; i<=6; i++) if(this.board[i].length>0 && this.board[i][0]===p) return false; return true; }

    executeMove(from, to, die) {
        let txt = (from==='BAR') ? `Bar ‚Üí ${to}` : (to==='OFF') ? `${from} ‚Üí ÌÉàÏ∂ú` : `${from} ‚Üí ${to}`;
        let icon = (this.turn===P1)?"üê∞":"üêª";
        ui.log(this.turn, `${icon} ${txt}`);

        let idx = this.moves.indexOf(die);
        if(idx > -1) this.moves.splice(idx, 1);
        else { this.moves.sort((a,b)=>b-a); this.moves.shift(); }

        if (from==='BAR') this.bar[this.turn]--; else this.board[from].pop();
        
        if (to==='OFF') {
            this.off[this.turn]++;
            ui.playSound('score');
        } else {
            let s = this.board[to];
            if(s.length===1 && s[0]!==this.turn) {
                this.bar[s.pop()]++;
                ui.toast("ÏÉÅÎåÄ ÎßêÏùÑ Ïû°ÏïòÏäµÎãàÎã§! üí•");
            }
            s.push(this.turn);
            ui.playSound('move');
        }

        this.selectedPoint = -1;
        this.validDestinations = [];
        this.hintMove = null;
        
        ui.updateBoard();
        ui.updateInfo(); 
        ui.updateDice(); 

        if (this.off[this.turn] === 15) {
            this.finishGame(false); 
            return;
        }

        if (this.moves.length === 0 || !this.hasValidMoves()) {
            setTimeout(() => this.endTurn(), 500);
        } else {
            if(!this.isPvP && this.turn===P2) setTimeout(()=>ai.play(), 800);
        }
    }

    endTurn() {
        this.turn = (this.turn===P1) ? P2 : P1;
        this.dice = [];
        this.hintMove = null;
        ui.updateBoard();
        ui.updateInfo(); 
        
        ui.setPhase('ROLL');
        if (!this.isPvP && this.turn === P2) {
            setTimeout(() => {
                if(ai.shouldDouble()) game.aiOfferDouble();
                else this.rollDice();
            }, 1000);
        }
    }

    saveState() {
        this.history.push({
            board: JSON.parse(JSON.stringify(this.board)),
            bar: {...this.bar}, off: {...this.off},
            turn: this.turn, dice: [...this.dice], moves: [...this.moves]
        });
    }

    undo() {
        if (this.history.length === 0) return;
        let state = this.history.pop();
        if (!this.isPvP) {
            while(state && state.turn === P2) {
                if(this.history.length===0) break;
                state = this.history.pop();
            }
        }
        if(state) {
            this.board = state.board; this.bar = state.bar; this.off = state.off;
            this.turn = state.turn; this.dice = state.dice; this.moves = state.moves;
            this.selectedPoint = -1; this.hintMove = null;
            ui.updateDice(this.dice[0], this.dice[1]);
            ui.updateBoard();
            ui.updateInfo();
            ui.setPhase(this.moves.length > 0 ? 'MOVE' : 'ROLL');
            ui.toast("Î¨¥Î•¥Í∏∞ ÏôÑÎ£å");
        }
    }

    getHint() {
        if (!this.isPvP && this.turn !== P1) return;
        if (this.moves.length === 0) return;

        let best = ai.findBestMove(this.turn, true);
        if(best) {
            this.hintMove = best;
            
            // [Simulation for Risk]
            let tempBoard = JSON.parse(JSON.stringify(this.board));
            let tempBar = {...game.bar};
            
            let s = (best.from==='BAR')?(this.turn===P1?0:25):best.from;
            let d = (best.to==='OFF')?(this.turn===P1?25:0):best.to;
            
            if(s===0 || s===25) {} else tempBoard[s].pop();
            
            if(d!==25 && d!==0) { 
                if(tempBoard[d].length===1 && tempBoard[d][0]!==this.turn) {
                    let hitP = tempBoard[d].pop();
                    tempBar[hitP]++; 
                    tempBoard[d].push(this.turn); 
                } else {
                    tempBoard[d].push(this.turn); 
                }
            }
            
            let risk = ai.calculateRiskProbability(tempBoard, this.turn, tempBar);
            let reason = best.reason || "Ï∂îÏ≤ú Ïàò";
            
            ui.updateBoard();
            ui.toast(`üí° Ï∂îÏ≤ú: ${best.from} ‚Üí ${best.to}\n(ÏúÑÌóòÎèÑ: ${risk}%) ${reason}`);
        } else {
            ui.toast("Í∞ÄÎä•Ìïú ÏàòÍ∞Ä ÏóÜÏäµÎãàÎã§.");
        }
    }

    humanOfferDouble() {
        if (!this.isPvP && this.turn !== P1) return; 

        if (this.isPvP) {
            let offerer = (this.turn === P1) ? "üê∞ P1" : "üêª P2";
            let receiver = (this.turn === P1) ? "üêª P2" : "üê∞ P1";
            ui.showModal('double', `${offerer}Ïù¥(Í∞Ä) ÎçîÎ∏îÏùÑ Ï†úÏïàÌñàÏäµÎãàÎã§.\n${receiver}, Î∞õÏúºÏãúÍ≤†ÏäµÎãàÍπå?`);
        } else {
            let take = ai.decideTake(this.cube * 2);
            if (take) {
                this.cube *= 2;
                this.cubeOwner = P2; 
                ui.updateScore();
                ui.toast("AIÍ∞Ä ÎçîÎ∏îÏùÑ ÏàòÎùΩÌñàÏäµÎãàÎã§!");
                ui.toggleRollBtn(true);
                ui.toggleDoubleBtn(false);
            } else {
                ui.toast("AIÍ∞Ä Ìè¨Í∏∞ÌñàÏäµÎãàÎã§. ÎãπÏã†Ïùò ÏäπÎ¶¨!");
                this.finishGame(true);
            }
        }
    }

    aiOfferDouble() {
        ui.showModal('double', `AIÍ∞Ä ÌåêÎèàÏùÑ ${this.cube * 2}Î∞∞Î°ú Ïò¨Î¶¨ÏûêÍ≥† Ìï©ÎãàÎã§.`);
    }

    resolveDouble(isTake) {
        ui.hide('modal-double');
        if (isTake) {
            this.cube *= 2;
            this.cubeOwner = (this.turn === P1) ? P2 : P1;
            ui.updateScore();
            ui.toast("ÎçîÎ∏î ÏàòÎùΩ! Ï£ºÏÇ¨ÏúÑÎ•º Íµ¥Î¶¨ÏÑ∏Ïöî.");
            if(this.isPvP) ui.setPhase('ROLL');
            else { if(this.turn === P2) setTimeout(() => this.rollDice(), 1000); }
        } else {
            this.finishGame(true); 
        }
    }

    finishGame(isDrop) {
        let winner = this.turn;
        let points = this.cube;
        let winnerName = (winner === P1) ? "üê∞ ÎãπÏã†" : (this.isPvP ? "üêª P2" : "üêª AI");
        let title = `${winnerName}Ïùò ÏäπÎ¶¨!`;
        let desc = "";
        
        if (!isDrop) {
            let loser = (winner === P1) ? P2 : P1;
            if (this.off[loser] === 0) {
                if (this.bar[loser] > 0 || this.hasCheckerInHome(loser, winner)) {
                    points *= 3; desc = "Î∞±Í∞úÎ®º ÏäπÎ¶¨ (3Î∞∞)";
                } else {
                    points *= 2; desc = "Í∞úÎ®º ÏäπÎ¶¨ (2Î∞∞)";
                }
            } else {
                desc = "ÏùºÎ∞ò ÏäπÎ¶¨";
            }
        } else {
            title = `${winnerName}Ïùò Í∏∞Í∂å Ïäπ`;
            desc = "ÏÉÅÎåÄÎ∞©Ïùò Í∏∞Í∂å";
        }
        
        this.matchScore[winner] += points;
        ui.updateScore();

        if (this.matchScore[winner] >= menu.targetScore) {
            let winText = (winner === P1) ? "üê∞ ÎãπÏã†Ïù¥ ÏµúÏ¢Ö Ïö∞Ïäπ!" : `${winnerName} ÏµúÏ¢Ö Ïö∞Ïäπ!`;
            if(this.isPvP) winText = (winner === P1) ? "üê∞ P1 ÏµúÏ¢Ö ÏäπÎ¶¨!" : "üêª P2 ÏµúÏ¢Ö ÏäπÎ¶¨!";
            ui.showWinModal(true, winText, `ÏµúÏ¢Ö Ïä§ÏΩîÏñ¥ ${this.matchScore[P1]} : ${this.matchScore[P2]}`);
            startConfetti();
        } else {
            ui.showWinModal(false, title, `ÌöçÎìù Ï†êÏàò: ${points}Ï†ê (${desc})`);
            if(winner === P1) startConfetti();
        }
    }

    hasCheckerInHome(loser, winner) {
        let start = (winner === P1) ? 19 : 1;
        let end = (winner === P1) ? 24 : 6;
        for(let i=start; i<=end; i++) if(this.board[i].includes(loser)) return true;
        return false;
    }

    nextRound() {
        ui.hide('modal-win'); stopConfetti();
        this.initRound();
    }
    toMenu() { 
        ui.hide('modal-win'); 
        ui.hide('modal-double');
        ui.hide('game-screen'); 
        ui.show('start-screen'); 
        stopConfetti();
    }
    
    getPip(player) {
        let pip = 0;
        for(let i=1; i<=24; i++) {
            if(this.board[i].length > 0 && this.board[i][0] === player) {
                let dist = (player === P1) ? (25 - i) : i;
                pip += (this.board[i].length * dist);
            }
        }
        pip += this.bar[player] * 25;
        return pip;
    }
}

class AI {
    play() {
        try {
            let best = this.findBestMove(P2, false);
            if(best) game.executeMove(best.from, best.to, best.die);
            else setTimeout(()=>game.endTurn(), 500);
        } catch (e) {
            console.error(e);
            game.endTurn();
        }
    }

    findBestMove(player, forceMax) {
        let sources = [];
        if(game.bar[player]>0) sources.push('BAR');
        else for(let i=1; i<=24; i++) if(game.board[i].includes(player)) sources.push(i);

        if(sources.length===0) return null;

        let best = null; let maxScore = -99999;
        let lvl = forceMax ? 5 : game.aiLevel;

        sources.forEach(src => {
            let originalTurn = game.turn;
            game.turn = player;
            let moves = game.getPossibleMoves(src);
            game.turn = originalTurn;

            moves.forEach(m => {
                let res = this.evalMove(src, m.dest, m.die, player, lvl);
                if(res.score > maxScore) { maxScore = res.score; best = {from: src, to: m.dest, die: m.die, reason: res.reason}; }
            });
        });
        return best;
    }

    evalMove(from, to, die, player, level) {
        let score = 0; let reason = "";
        let isP1 = (player === P1);
        
        if (to === 'OFF') return {score: 99999, reason: "ÏäπÎ¶¨Î•º ÏúÑÌï¥ ÌÉàÏ∂úÌï©ÎãàÎã§!"};

        let destStack = game.board[to];
        let opponent = isP1 ? P2 : P1;
        let isHit = (destStack.length === 1 && destStack[0] === opponent);
        let isBuild = (destStack.length === 1 && destStack[0] === player);
        let progress = isP1 ? to : (25 - to); 

        switch (level) {
            case 1: score = Math.random() * 1000; break;
            case 2: if (isHit) score += 5000; score += progress; break;
            case 3: if (isBuild) score += 2000; score += progress; break;
            case 4: 
            case 5:
                score += progress; 
                
                // [FIX] Hit Score Logic Reversed & Symmetrical
                if (isHit) {
                    let hitBase = 40;
                    let safeZoneBonus = 0;
                    
                    // P1(White): Moves 1->24. Home 19-24. 
                    // P1's safe hit zone is 1-18 (far from P2 entry at 24).
                    // P2(Black): Moves 24->1. Home 1-6.
                    // P2's safe hit zone is 7-24 (far from P1 entry at 1).
                    
                    if (isP1) {
                        if (to <= 18) safeZoneBonus = 30; // Outer hit (Safe)
                    } else {
                        if (to >= 7) safeZoneBonus = 30; // Outer hit (Safe)
                    }
                    
                    score += hitBase + safeZoneBonus;
                    reason = safeZoneBonus > 0 ? "ÏïàÏ†ÑÌïú Í≥≥ÏóêÏÑú ÏÉÅÎåÄÎ•º Ï†úÏïïÌï©ÎãàÎã§." : "Í≥µÍ≤©";
                }

                // Build Logic
                if (isBuild) {
                    let buildBase = 40;
                    if (this.isConnected(to, player)) { buildBase += 30; reason = "Î≤ΩÏùÑ ÏÑ∏Ïõå ÏÉÅÎåÄÎ•º Í∞ÄÎë°ÎãàÎã§."; }
                    
                    // Home Board Build is critical for both
                    let isHome = (isP1 && to >= 19) || (!isP1 && to <= 6);
                    if (isHome) { buildBase += 50; reason = "Ìôà Î≥¥ÎìúÎ•º Í∞ïÎ†•ÌïòÍ≤å Íµ¨Ï∂ïÌï©ÎãàÎã§."; }
                    
                    score += buildBase;
                }

                // [CRITICAL] Risk Logic with Hit consideration
                // If we hit, opponent will be on bar. We must check re-entry risk.
                let opponentOnBar = game.bar[opponent] > 0 || isHit;
                
                if (!isBuild && this.isRisky(to, player, opponentOnBar)) { 
                    score -= 200; 
                    reason = "ÏúÑÌóòÌï©ÎãàÎã§. (Ïó≠Í≥µ Ï£ºÏùò)"; 
                }
                
                if (!isHit && !isBuild && score > 0 && !reason) { reason = "ÏïàÏ†ÑÌïòÍ≤å Ïù¥ÎèôÌï©ÎãàÎã§."; }
                break;
        }
        return {score, reason};
    }

    isConnected(idx, player) {
        let neighbors = [idx-1, idx+1];
        for(let n of neighbors) {
            if(n>=1 && n<=24 && game.board[n].length >= 2 && game.board[n][0] === player) return true;
        }
        return false;
    }

    // [FIX] Symmetrical Risk Check (P1 vs P2)
    isRisky(targetIdx, player, opponentOnBar) {
        let opponent = (player === P1) ? P2 : P1;
        
        // 1. Re-entry Risk (If opponent is on bar)
        if (opponentOnBar) {
            let myHomeStart = (player === P1) ? 19 : 1;
            let myHomeEnd = (player === P1) ? 24 : 6;
            // If I am in my home (their entry zone), it's risky
            if (targetIdx >= myHomeStart && targetIdx <= myHomeEnd) return true;
        }

        // 2. Board Risk (Opponent nearby)
        let start = targetIdx + 1;
        let end = Math.min(24, targetIdx + 6);
        // If P2, opponent (P1) is "behind" in indices (moves 1->24)
        // Wait, P2 moves 24->1. "Behind" means higher index? No.
        // P2 at 20. P1 comes from 1. P1 hits 20 from 14-19.
        // So we check targetIdx - 6 to targetIdx - 1.
        if (player === P2) { start = Math.max(1, targetIdx - 6); end = targetIdx - 1; }
        
        for (let i = start; i <= end; i++) {
            if (game.board[i].length > 0 && game.board[i][0] === opponent) return true;
        }
        return false;
    }

    calculateWinScore() {
        let score = 50; 
        let p1Pip = game.getPip(P1);
        let p2Pip = game.getPip(P2);

        let isBearingOff = (game.off[P2] > 0 || game.off[P1] > 0);
        
        if (isBearingOff) {
            score += (game.off[P2] - game.off[P1]) * 20; 
            score += (p1Pip - p2Pip) * 0.8;
        } else {
            score += (p1Pip - p2Pip) * 0.5;
            let aiHome = this.countHomePoints(P2);
            let p1Home = this.countHomePoints(P1);
            score += (aiHome - p1Home) * 6;
            score += game.bar[P1] * 12;
            score -= game.bar[P2] * 12;
        }
        return score;
    }

    countHomePoints(player) {
        let count = 0;
        let start = (player === P1) ? 19 : 1;
        let end = (player === P1) ? 24 : 6;
        for (let i = start; i <= end; i++) {
            if (game.board[i].length >= 2 && game.board[i][0] === player) count++;
        }
        return count;
    }

    calculateRiskProbability(tempBoard, player, tempBar = game.bar) {
        let opponent = (player === P1) ? P2 : P1;
        let hitCount = 0;
        let blots = [];
        for(let i=1; i<=24; i++) if(tempBoard[i].length === 1 && tempBoard[i][0] === player) blots.push(i);
        if(blots.length === 0) return 0;

        for (let d1 = 1; d1 <= 6; d1++) {
            for (let d2 = 1; d2 <= 6; d2++) {
                if (this.canOpponentHit(tempBoard, opponent, blots, d1, d2, tempBar)) hitCount++;
            }
        }
        return ((hitCount / 36) * 100).toFixed(1);
    }

    canOpponentHit(board, opponent, blots, d1, d2, bar) {
        let moves = [d1, d2];
        if (d1 === d2) moves = [d1, d1, d1, d1]; 

        // 1. Re-entry Hit Check (Most Dangerous)
        if (bar[opponent] > 0) {
            let start = (opponent === P1) ? 0 : 25;
            let dir = (opponent === P1) ? 1 : -1;
            for (let m of moves) {
                let dest = start + (m * dir);
                if (blots.includes(dest)) return true;
            }
            return false; 
        }

        // 2. Normal Hit Check
        let sources = [];
        for(let i=1; i<=24; i++) if(board[i].includes(opponent)) sources.push(i);

        for(let src of sources) {
            let start = src;
            let dir = (opponent === P1) ? 1 : -1;
            for (let m of moves) {
                let dest = start + (m * dir);
                if(blots.includes(dest)) return true;
            }
            if(moves.length >= 2) {
                let comboDest = start + ((moves[0] + moves[1]) * dir);
                if(blots.includes(comboDest)) return true;
            }
        }
        return false;
    }

    shouldDouble() {
        if (game.cubeOwner !== 0 && game.cubeOwner !== P2) return false;
        if (game.aiLevel === 1) return false;
        
        if (game.aiLevel < 5) {
            let lead = game.getPip(P1) - game.getPip(P2);
            let threshold = (game.aiLevel === 2) ? 5 : (game.aiLevel === 3 ? 30 : 20);
            return lead > threshold && Math.random() > 0.3;
        }

        let winScore = this.calculateWinScore();
        return winScore >= 72 && Math.random() > 0.2;
    }

    decideTake(val) {
        if (game.aiLevel === 1) return true;
        if (game.aiLevel < 5) {
            let lead = game.getPip(P2) - game.getPip(P1);
            let limit = (game.aiLevel === 2) ? 60 : (game.aiLevel === 3) ? 20 : 40;
            return lead < limit;
        }

        let winScore = this.calculateWinScore();
        if (winScore < 22) return false;
        if (winScore < 30) return Math.random() > 0.7;
        return true;
    }
}

const renderer = {
    canvas: document.getElementById('board'),
    ctx: document.getElementById('board').getContext('2d'),
    
    resize: () => {
        let p = document.getElementById('board-container');
        const dpr = window.devicePixelRatio || 1;
        
        renderer.canvas.style.width = p.clientWidth + 'px';
        renderer.canvas.style.height = p.clientHeight + 'px';
        
        renderer.canvas.width = p.clientWidth * dpr;
        renderer.canvas.height = p.clientHeight * dpr;
        
        renderer.ctx.setTransform(1, 0, 0, 1, 0, 0);
        renderer.ctx.scale(dpr, dpr);
        
        renderer.w = p.clientWidth;
        renderer.h = p.clientHeight;
        renderer.draw();
    },

    draw: () => {
        const ctx = renderer.ctx;
        const w = renderer.w, h = renderer.h;
        if(!w) return;

        ctx.clearRect(0,0,w,h);
        
        ctx.fillStyle = '#D7CCC8';
        ctx.fillRect(0,0,w,h);
        
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 4;
        ctx.strokeRect(0,0,w,h);

        const barW = w * 0.08;
        const triW = (w - barW) / 12;
        const triH = h * 0.42; 

        // [RESTORED] Draw Numbers
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';

        for(let i=1; i<=24; i++) {
            let pos = renderer.getPos(i, w, h, triW, barW, triH);
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.baseY);
            ctx.lineTo(pos.x + triW, pos.baseY);
            ctx.lineTo(pos.x + triW/2, pos.tipY);
            ctx.fillStyle = (i%2===0) ? '#5D4037' : '#FFCC80';
            if(i>=13) ctx.fillStyle = (i%2!==0) ? '#5D4037' : '#FFCC80';
            ctx.fill();
            
            // Numbers
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            let numY = pos.isTop ? 20 : h - 10;
            ctx.fillText(i, pos.x + triW/2, numY);

            if (game.validDestinations.includes(i)) {
                ctx.beginPath();
                ctx.arc(pos.x + triW/2, (pos.baseY + pos.tipY)/2, triW/4, 0, Math.PI*2);
                ctx.fillStyle = '#00E676';
                ctx.fill();
                ctx.lineWidth = 3; ctx.strokeStyle = 'white'; ctx.stroke();
            }

            let stack = game.board[i];
            let r = Math.min(triW/2 - 2, 16); 
            if (document.body.classList.contains('pc-layout')) r = Math.min(triW/2 - 2, 22);

            stack.forEach((p, idx) => {
                let cy = pos.isTop ? pos.baseY + r + 3 + (idx*r*2) : pos.baseY - r - 3 - (idx*r*2);
                if(stack.length > 5) cy = pos.isTop ? pos.baseY + r + (idx*((triH-r)/stack.length)) : pos.baseY - r - (idx*((triH-r)/stack.length));
                renderer.drawPiece(pos.x + triW/2, cy, r, p, (game.selectedPoint === i && idx === stack.length-1));
            });
        }

        ctx.fillStyle = '#4E342E';
        ctx.fillRect((w-barW)/2, 0, barW, h);
        
        let p1b = game.bar[P1], p2b = game.bar[P2];
        let rBar = 18;
        if(document.body.classList.contains('pc-layout')) rBar = 20;

        for(let i=0; i<p1b; i++) renderer.drawPiece(w/2, h*0.75 + (i*15), rBar, P1, (game.selectedPoint==='BAR' && i===p1b-1));
        for(let i=0; i<p2b; i++) renderer.drawPiece(w/2, h*0.25 - (i*15), rBar, P2, false);

        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(w-35, 0, 35, h); 
        if (game.validDestinations.includes('OFF')) {
            ctx.fillStyle = 'rgba(0,255,0,0.4)';
            ctx.fillRect(w-35, (game.turn===P1?0:h/2), 35, h/2);
        }

        if (game.hintMove) {
            let from = game.hintMove.from;
            let to = game.hintMove.to;
            let start = renderer.getCenter(from, w, h, triW, barW, triH);
            let end = renderer.getCenter(to, w, h, triW, barW, triH);
            
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#00BCD4';
            ctx.lineCap = 'round';
            ctx.stroke();
            
            ctx.beginPath(); ctx.arc(start.x, start.y, 6, 0, Math.PI*2);
            ctx.fillStyle = '#00BCD4'; ctx.fill();
            ctx.beginPath(); ctx.arc(end.x, end.y, 6, 0, Math.PI*2);
            ctx.fill();
        }
    },

    getPos: (i, w, h, tw, bw, th) => {
        let x, baseY, tipY, isTop;
        if (i<=6) { x = w - (i*tw); baseY = h; tipY = h - th; isTop=false; }
        else if (i<=12) { x = w - bw - (i*tw); baseY = h; tipY = h - th; isTop=false; }
        else if (i<=18) { x = w - bw - ((25-i)*tw); baseY = 0; tipY = th; isTop=true; }
        else { x = w - ((25-i)*tw); baseY = 0; tipY = th; isTop=true; }
        return {x, baseY, tipY, isTop};
    },

    getCenter: (i, w, h, tw, bw, th) => {
        if(i==='BAR') return {x: w/2, y: (game.turn===P1 ? h*0.75 : h*0.25)};
        if(i==='OFF') return {x: w-17, y: (game.turn===P1 ? h*0.25 : h*0.75)};
        let p = renderer.getPos(i, w, h, tw, bw, th);
        return {x: p.x + tw/2, y: (p.baseY + p.tipY)/2};
    },

    drawPiece: (x, y, r, p, selected) => {
        const ctx = renderer.ctx;
        if (selected) {
            ctx.beginPath(); ctx.arc(x, y, r+6, 0, Math.PI*2);
            ctx.fillStyle = '#FFD700'; ctx.fill(); 
        }
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = (p===P1) ? '#F5F5F5' : '#3E2723';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#333';
        ctx.stroke();
    }
};

function handleInput(e) {
    if (!game.isPvP && game.turn !== P1) return;
    if (e.type === 'touchstart') e.preventDefault(); 

    const rect = renderer.canvas.getBoundingClientRect();
    let clientX = e.clientX;
    let clientY = e.clientY;

    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    }

    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const w = renderer.w;
    
    if(x > w-35) { handleClick('OFF'); return; }
    if(x > w/2 - 25 && x < w/2 + 25) { if(game.bar[game.turn]>0) handleClick('BAR'); return; }

    const bw = w * 0.08, tw = (w - bw) / 12;
    let idx = -1;
    
    for(let i=1; i<=24; i++) {
        let p = renderer.getPos(i, w, renderer.h, tw, bw, renderer.h*0.42);
        if (x >= p.x && x <= p.x+tw) {
            if ((!p.isTop && y > renderer.h/2) || (p.isTop && y < renderer.h/2)) idx = i;
        }
    }
    if (idx !== -1) handleClick(idx);
}

renderer.canvas.addEventListener('mousedown', handleInput);
renderer.canvas.addEventListener('touchstart', handleInput, {passive: false});

function handleClick(idx) {
    if (game.selectedPoint !== -1) {
        let valid = game.getPossibleMoves(game.selectedPoint);
        let match = valid.find(m => m.dest === idx);
        if (match) {
            game.executeMove(game.selectedPoint, idx, match.die);
            return;
        }
    }
    
    if (idx === 'BAR' && game.bar[game.turn] > 0) game.selectedPoint = 'BAR';
    else if (idx !== 'OFF' && game.board[idx].length > 0 && game.board[idx][0] === game.turn) game.selectedPoint = idx;
    else game.selectedPoint = -1;
    
    if (game.selectedPoint !== -1) {
        game.validDestinations = game.getPossibleMoves(game.selectedPoint).map(m => m.dest);
    } else {
        game.validDestinations = [];
    }
    renderer.draw();
}

const ui = {
    setMode: (mode) => {
        const body = document.body;
        body.classList.remove('pc-layout', 'mobile-layout');
        body.classList.add(mode + '-layout');
        
        const btnUndo = document.getElementById('btn-undo');
        const btnHint = document.getElementById('btn-hint');
        const btnMenu = document.querySelector('.btn-sub:last-child');
        const btnRoll = document.getElementById('btn-roll');

        if (mode === 'mobile') {
            btnUndo.innerHTML = '‚Ü©Ô∏è';
            btnHint.innerHTML = 'üí°';
            btnMenu.innerHTML = 'üè†';
            btnRoll.innerHTML = 'üé≤ Íµ¥Î¶¨Í∏∞';
        } else {
            btnUndo.innerHTML = '<span class="btn-text">Î¨¥Î•¥Í∏∞</span>';
            btnHint.innerHTML = '<span class="btn-text">ÌûåÌä∏</span>';
            btnMenu.innerHTML = '<span class="btn-text">Î©îÎâ¥</span>';
            btnRoll.innerHTML = 'üé≤ Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Í∏∞';
        }

        ui.hide('mode-select-screen');
        ui.show('start-screen');
        setTimeout(() => renderer.resize(), 100);
    },

    show: (id) => document.getElementById(id).classList.remove('hidden'),
    hide: (id) => document.getElementById(id).classList.add('hidden'),
    showModal: (id, txt) => {
        if(id==='double') document.getElementById('double-msg').innerText = txt;
        else document.getElementById('win-desc').innerText = txt;
        ui.show('modal-'+id);
    },
    showWinModal: (isMatchWin, title, desc) => {
        document.getElementById('win-title').innerText = title;
        document.getElementById('win-desc').innerText = desc;
        
        const btn = document.getElementById('btn-win-action');
        if (isMatchWin) {
            btn.innerText = "üè† Î©îÏù∏ Î©îÎâ¥Î°ú (ÏµúÏ¢Ö ÏäπÎ¶¨)";
            btn.onclick = () => game.toMenu();
            btn.style.backgroundColor = "#E91E63"; 
        } else {
            btn.innerText = "Îã§Ïùå ÎùºÏö¥Îìú";
            btn.onclick = () => game.nextRound();
            btn.style.backgroundColor = "#FF6F00";
        }
        ui.show('modal-win');
    },
    updateScore: () => {
        document.getElementById('score-p1').innerText = game.matchScore[P1];
        document.getElementById('score-p2').innerText = game.matchScore[P2];
        document.getElementById('cube-val').innerText = game.cube;
        let ownerText = "Ï§ëÏïô";
        if(game.cubeOwner === P1) ownerText = "üê∞ ÎÇò";
        if(game.cubeOwner === P2) ownerText = "üêª P2";
        document.getElementById('cube-owner').innerText = ownerText;
    },
    updateInfo: () => {
        const el1 = document.getElementById('pip-p1');
        const el2 = document.getElementById('pip-p2');
        const new1 = game.getPip(P1);
        const new2 = game.getPip(P2);
        el1.innerText = new1;
        el2.innerText = new2;
        
        document.getElementById('p1-box').classList.toggle('active', game.turn === P1);
        document.getElementById('p2-box').classList.toggle('active', game.turn === P2);
    },
    updateDice: (d1, d2) => {
        if(d1 !== undefined && d1 !== null) {
            document.getElementById('die1').innerText = d1;
            document.getElementById('die2').innerText = d2;
            document.querySelectorAll('.die').forEach(e => e.classList.remove('used'));
        } else {
            let els = document.querySelectorAll('.die');
            if (game.moves.length === 0) els.forEach(e => e.classList.add('used'));
            else if (game.dice[0] !== game.dice[1] && game.moves.length === 1) {
                let usedDie = (game.moves[0] === game.dice[0]) ? game.dice[1] : game.dice[0];
                if (usedDie === parseInt(els[0].innerText)) els[0].classList.add('used');
                else els[1].classList.add('used');
            }
        }
        const ml = document.getElementById('moves-left');
        ml.innerText = `ÎÇ®ÏùÄ: ${game.moves.length}`;
        ml.classList.toggle('show', game.moves.length > 0);
    },
    updateBoard: () => { renderer.draw(); },
    setPhase: (p) => {
        let isMyTurn = game.isPvP || (game.turn === P1);
        
        const btnRoll = document.getElementById('btn-roll');
        const btnDouble = document.getElementById('btn-double');
        const btnUndo = document.getElementById('btn-undo');
        const msg = document.getElementById('msg-box');

        btnRoll.disabled = !isMyTurn || (p !== 'ROLL');
        
        let iCanDouble = (game.cubeOwner === 0) || (game.cubeOwner === game.turn);
        btnDouble.disabled = !isMyTurn || !iCanDouble || game.crawford || (p !== 'ROLL');
        
        btnUndo.disabled = !isMyTurn;

        if (isMyTurn) {
            let playerIcon = (game.turn === P1) ? "üê∞ ÎÇò" : "üêª P2";
            msg.innerText = (p === 'ROLL') ? `${playerIcon}: Íµ¥Î¶¨ÏÑ∏Ïöî` : `${playerIcon}: Ïù¥ÎèôÌïòÏÑ∏Ïöî`;
        } else {
            msg.innerText = "ÏÉÅÎåÄ ÌÑ¥...";
        }
    },
    toggleRollBtn: (en) => document.getElementById('btn-roll').disabled = !en,
    toggleDoubleBtn: (en) => document.getElementById('btn-double').disabled = !en,
    setMsg: (t) => document.getElementById('msg-box').innerText = t,
    log: (p, t) => {},
    toast: (msg) => {
        let t = document.getElementById('toast');
        t.innerText = msg; t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), 3000);
    },
    playSound: (t) => {}
};

let game = new Backgammon();
let ai = new AI();
window.onload = () => { ui.show('mode-select-screen'); window.addEventListener('resize', renderer.resize); };

// Confetti
const cvs = document.getElementById('confetti-canvas');
const c2d = cvs.getContext('2d');
let particles = [], animId;
function resizeConfetti() { cvs.width = window.innerWidth; cvs.height = window.innerHeight; }
window.addEventListener('resize', resizeConfetti); resizeConfetti();
function createParticle() { return { x: Math.random()*cvs.width, y: Math.random()*cvs.height-cvs.height, size: Math.random()*5+5, speedY: Math.random()*3+2, speedX: Math.random()*2-1, color: `hsl(${Math.random()*360},100%,50%)` }; }
function startConfetti() { stopConfetti(); particles = Array.from({length:60}, createParticle); animateConfetti(); }
function stopConfetti() { if(animId) cancelAnimationFrame(animId); particles = []; c2d.clearRect(0,0,cvs.width,cvs.height); }
function animateConfetti() {
    c2d.clearRect(0,0,cvs.width,cvs.height);
    particles.forEach((p, i) => {
        p.y += p.speedY; p.x += p.speedX; 
        if(p.y > cvs.height) particles[i] = createParticle();
        c2d.fillStyle = p.color; c2d.fillRect(p.x, p.y, p.size, p.size);
    });
    animId = requestAnimationFrame(animateConfetti);
}
</script>
</body>
</html>